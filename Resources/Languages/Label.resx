<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
		Microsoft ResX Schema

		Version 1.3

		The primary goals of this format is to allow a simple XML format 
		that is mostly human readable. The generation and parsing of the 
		various data types are done through the TypeConverter classes 
		associated with the data types.

		Example:

		... ado.net/XML headers & schema ...
		<resheader name="resmimetype">text/microsoft-resx</resheader>
		<resheader name="version">1.3</resheader>
		<resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
		<resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
		<data name="Name1">this is my long string</data>
		<data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
		<data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
			[base64 mime encoded serialized .NET Framework object]
		</data>
		<data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
			[base64 mime encoded string representing a byte array form of the .NET Framework object]
		</data>

		There are any number of "resheader" rows that contain simple 
		name/value pairs.

		Each data row contains a name, and value. The row also contains a 
		type or mimetype. Type corresponds to a .NET class that support 
		text/value conversion through the TypeConverter architecture. 
		Classes that don't support this are serialized and stored with the 
		mimetype set.

		The mimetype is used for serialized objects, and tells the 
		ResXResourceReader how to depersist the object. This is currently not 
		extensible. For a given mimetype the value must be set accordingly:

		Note - application/x-microsoft.net.object.binary.base64 is the format 
		that the ResXResourceWriter will generate, however the reader can 
		read any of the formats listed below.

		mimetype: application/x-microsoft.net.object.binary.base64
		value   : The object must be serialized with 
			: System.Serialization.Formatters.Binary.BinaryFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.soap.base64
		value   : The object must be serialized with 
			: System.Runtime.Serialization.Formatters.Soap.SoapFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.bytearray.base64
		value   : The object must be serialized into a byte array 
			: using a System.ComponentModel.TypeConverter
			: and then encoded with base64 encoding.
	-->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>1.3</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="lbl_ARCGIS_APIKey" xml:space="preserve">
    <value>ARCGIS API Key</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_GeoNames_Pwd" xml:space="preserve">
    <value>GeoNames Password</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_GeoNames_UserName" xml:space="preserve">
    <value>GeoNames Username</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_ParseProgress_Read" xml:space="preserve">
    <value>Reading:</value>
    <comment>Location: Main Form</comment>
  </data>
  <data name="lbl_ParseProgress_Write" xml:space="preserve">
    <value>Writing:</value>
    <comment>Location: Main Form</comment>
  </data>
  <data name="lbl_ParseProgress_Normal" xml:space="preserve">
    <value>Ready</value>
    <comment>Location: Main Form</comment>
  </data>
  <data name="lbl_Startup_Folder" xml:space="preserve">
    <value>Startup Folder</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_Language" xml:space="preserve">
    <value>Language</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_QuestionAddToponomy" xml:space="preserve">
    <value>Do you want to also assign Altitude and Toponomy values?
If you pick No, your lat/long data may become out of sync with any embedded toponomy data.
If you click 'stop asking' it will take the answer as Yes and won't ask again this session. Restart to reset.</value>
    <comment>Location: Main Form</comment>
  </data>
  <data name="lbl_ImportTimeAgainst" xml:space="preserve">
    <value>Compare the timestamp in the Track Files against:</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_ShiftTrackTimeBy" xml:space="preserve">
    <value>Shift Track File Time by:</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_CameraTime" xml:space="preserve">
    <value>Camera Date/Time</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_TZTime" xml:space="preserve">
    <value>Time Zone Adjustment:</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_TZNote" xml:space="preserve">
    <value>Note: If the date/time tag does not include a timezone then one may be added (see below), otherwise the local system time is assumed.</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_CameraTimeNote" xml:space="preserve">
    <value>Note: Time Shift is needed only when the image timestamps are not properly synchronized with GPS time. Leave as 0s unless required.</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_importOneFile" xml:space="preserve">
    <value>&lt;-- Click there set the Import Source File</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_importFromAnotherFolder" xml:space="preserve">
    <value>&lt;-- Click there set the Import Source Folder</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_GeoMaxIntSecs" xml:space="preserve">
    <value>Max interpolation ('path guessing') time in seconds. Set to 0 to disable.</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_GeoMaxExtSecs" xml:space="preserve">
    <value>Max extrapolation (time diff between Taken TimeStamp and Trackpoint TS) time in seconds.</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_OffsetTime" xml:space="preserve">
    <value>Time Zone</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_SelectColsTitle" xml:space="preserve">
    <value>Select Columns</value>
    <comment>Location: Main Form</comment>
  </data>
  <data name="lbl_ChoiceOfferCount" xml:space="preserve">
    <value>Show this many toponym options</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_ChoiceRadius" xml:space="preserve">
    <value>In the Radius [kms]</value>
    <comment>Location: Settings</comment>
  </data>
  <data name="lbl_SaveTrackTo" xml:space="preserve">
    <value>Save Output To</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_ExportTrackOrderBy" xml:space="preserve">
    <value>Sort TrackPoints by</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_ExportTrackTimeStampType" xml:space="preserve">
    <value>TimeStamp Value</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_ExportTrackTimeStampTypeNote" xml:space="preserve">
    <value>If you select GPSDateTime and your file has no such attribute the export will fail. 
Some HEIC files have this, most other formats don't.</value>
    <comment>Location: Import/Export GPX</comment>
  </data>
  <data name="lbl_ParsingFolders" xml:space="preserve">
    <value>Parsing Files &amp;&amp; Folders, please wait. </value>
    <comment>Location: "Please Wait" Form</comment>
  </data>
  <data name="lbl_CancelPressed" xml:space="preserve">
    <value>Cancel Pressed. Folder parsing has stopped but files that have been collected will be parsed.</value>
    <comment>Location: "Please Wait" Form</comment>
  </data>
  <data name="lbl_PleaseWaitBoxActionParsing" xml:space="preserve">
    <value>Parsing Data:</value>
    <comment>Location: "Please Wait" Form</comment>
  </data>
  <data name="lbl_PleaseWaitBoxActionScanning" xml:space="preserve">
    <value>Scanning File:</value>
    <comment>Location: "Please Wait" Form</comment>
  </data>
  <data name="lbl_PressCancelToStop" xml:space="preserve">
    <value>Press Cancel to stop.</value>
    <comment>Location: "Please Wait" Form</comment>
  </data>
</root>